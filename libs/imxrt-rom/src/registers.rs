//! Registers that are available as OTP fuses and as shadow registers.
#![allow(dead_code)]

mod device;

use device_driver::RegisterInterface;

use crate::otp::Otp;

// Include the device driver definition.
// Can be regenerated by running `device-driver-cli -m registers.json -o src/registers/device.rs --device-name Device`.
// Will cause the GH workflow to SIGPIPE if included directly.
include!("registers/device.rs");

/// Interface to access the shadow registers.
pub struct ShadowInterface {
    _private: (),
}

#[derive(Debug, PartialEq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct NotShadowRegister;

/// Convert an OTP word index to offset in the shadow register block.
const fn otp_to_shadow_offset(otp_word_i: u32) -> Result<usize, NotShadowRegister> {
    let shadow_offset = match otp_word_i {
        8..=9 => (otp_word_i - 8) * 4 + 0x020,
        95..=104 => (otp_word_i - 95) * 4 + 0x17C,
        106..=127 => (otp_word_i - 106) * 4 + 0x1A8,
        492..=495 => (otp_word_i - 492) * 4 + 0x7B0,
        _ => return Err(NotShadowRegister),
    };

    Ok(shadow_offset as usize)
}

/// Convert an OTP word index to address in the shadow register block.
fn otp_to_shadow_addr(otp_word_i: u32) -> Result<*mut u32, NotShadowRegister> {
    const OTP_SHADOW_BASE_ADDR: usize = 0x40130000;
    Ok((OTP_SHADOW_BASE_ADDR + otp_to_shadow_offset(otp_word_i)?) as *mut u32)
}

impl RegisterInterface for ShadowInterface {
    type Error = NotShadowRegister;
    type AddressType = u32;

    fn write_register(
        &mut self,
        otp_word_i: Self::AddressType,
        _size_bits: u32,
        data: &[u8],
    ) -> Result<(), Self::Error> {
        for (chunk_i, chunk) in data.chunks(4).enumerate() {
            let otp_word_i = otp_word_i + chunk_i as u32;
            let shadow_addr = otp_to_shadow_addr(otp_word_i)?;

            let word = if chunk.len() != 4 {
                let mut buf = [0u8; 4];
                buf[..chunk.len()].copy_from_slice(chunk);
                u32::from_le_bytes(buf)
            } else {
                // Safety: we have chunks of exactly 4 bytes, hence the conversion to [u8; 4] is safe.
                u32::from_le_bytes(unsafe { chunk.try_into().unwrap_unchecked() })
            };

            // Safety: we assume that the register yaml definition is correct, and that each register is aligned.
            unsafe { shadow_addr.write_volatile(word) };
        }
        Ok(())
    }

    fn read_register(
        &mut self,
        otp_word_i: Self::AddressType,
        _size_bits: u32,
        data: &mut [u8],
    ) -> Result<(), Self::Error> {
        // Safety: we assume that the register yaml definition is correct, no need for volatile memory access.
        let shadow_addr = otp_to_shadow_addr(otp_word_i)? as *const u8;
        let source = unsafe { core::slice::from_raw_parts(shadow_addr, data.len()) };
        data.copy_from_slice(source);
        Ok(())
    }
}

pub struct OtpInterface<'a> {
    otp: &'a mut Otp,
    allow_write: bool,
    mode_locked: bool,
}

#[derive(Debug)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum OtpError {
    WriteNotAllowed,
    Inner(crate::otp::Error),
}

impl From<crate::otp::Error> for OtpError {
    fn from(value: crate::otp::Error) -> Self {
        OtpError::Inner(value)
    }
}

impl RegisterInterface for OtpInterface<'_> {
    type Error = OtpError;
    type AddressType = u32;

    fn write_register(&mut self, address: Self::AddressType, _size_bits: u32, data: &[u8]) -> Result<(), Self::Error> {
        if !self.allow_write {
            return Err(OtpError::WriteNotAllowed);
        }

        for (i, chunk) in data.chunks_exact(4).enumerate() {
            // Safety: we have chunks of exactly 4 bytes, hence the conversion to [u8; 4] is safe.
            let word = u32::from_le_bytes(unsafe { chunk.try_into().unwrap_unchecked() });

            self.otp.write_fuse(address + i as u32, word, self.mode_locked)?;
        }
        Ok(())
    }

    fn read_register(
        &mut self,
        address: Self::AddressType,
        _size_bits: u32,
        data: &mut [u8],
    ) -> Result<(), Self::Error> {
        for (i, chunk) in data.chunks_exact_mut(4).enumerate() {
            chunk.copy_from_slice(&self.otp.read_fuse(address + i as u32)?.to_le_bytes());
        }
        Ok(())
    }
}

pub struct ShadowRegisters {
    device: Device<ShadowInterface>,
}

impl ShadowRegisters {
    pub const fn new() -> Self {
        Self {
            device: Device::new(ShadowInterface { _private: () }),
        }
    }
}

impl Default for ShadowRegisters {
    fn default() -> Self {
        Self::new()
    }
}

impl core::ops::Deref for ShadowRegisters {
    type Target = Device<ShadowInterface>;

    fn deref(&self) -> &Self::Target {
        &self.device
    }
}

impl core::ops::DerefMut for ShadowRegisters {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.device
    }
}

pub struct OtpFuses<'a> {
    device: Device<OtpInterface<'a>>,
}

impl<'a> OtpFuses<'a> {
    pub fn readonly(otp: &'a mut Otp) -> Self {
        Self {
            device: Device::new(OtpInterface {
                otp,
                allow_write: false,
                mode_locked: false,
            }),
        }
    }

    pub fn writable(otp: &'a mut Otp, mode_locked: bool) -> Self {
        Self {
            device: Device::new(OtpInterface {
                otp,
                allow_write: true,
                mode_locked,
            }),
        }
    }
}

impl<'a> core::ops::Deref for OtpFuses<'a> {
    type Target = Device<OtpInterface<'a>>;

    fn deref(&self) -> &Self::Target {
        &self.device
    }
}

impl core::ops::DerefMut for OtpFuses<'_> {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.device
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn mapping() {
        assert_eq!(otp_to_shadow_offset(96), Ok(0x180)); // BOOT_CFG[0]
        assert_eq!(otp_to_shadow_offset(97), Ok(0x184)); // BOOT_CFG[1]
        assert_eq!(otp_to_shadow_offset(101), Ok(0x194)); // SEC_BOOT_CFG[5]
        assert_eq!(otp_to_shadow_offset(120), Ok(0x1E0)); // RKTH[0]
        assert_eq!(otp_to_shadow_offset(127), Ok(0x1FC)); // RKTH[7]
    }
}
